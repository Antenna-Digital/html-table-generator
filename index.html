<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Table Generator for Webflow</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          fontFamily: {
            sans: ['Inter', 'Segoe UI', 'Tahoma', 'Geneva', 'Verdana', 'sans-serif'],
          },
          extend: {
            colors: {
              neutralbg: '#f8fafc',
              accent: '#2563eb',
              accentlight: '#e0e7ff',
              danger: '#ef4444',
              glass: 'rgba(255,255,255,0.7)',
            },
            boxShadow: {
              glass: '0 8px 32px 0 rgba(31, 38, 135, 0.18)',
            },
            backdropBlur: {
              xs: '2px',
            },
          },
        },
      }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
</head>
<body class="min-h-screen font-sans bg-gradient-to-br from-accentlight via-neutralbg to-white flex items-center justify-center py-10">
    <div class="container mx-auto max-w-6xl px-4">
      <div class="relative rounded-3xl shadow-glass border border-gray-200 bg-glass backdrop-blur-md backdrop-blur-xs p-0 overflow-hidden" style="box-shadow: 0 8px 32px 0 rgba(31,38,135,0.18);">
        <div class="bg-gradient-to-r from-white/80 to-accentlight/60 text-gray-900 py-12 px-10 text-center rounded-t-3xl border-b border-gray-100">
          <h1 class="text-5xl font-extrabold mb-3 tracking-tight drop-shadow-sm">HTML Table Generator</h1>
          <p class="text-lg opacity-80 font-medium max-w-2xl mx-auto">Create clean, beautiful HTML tables for your Webflow projects. Effortlessly design, edit, and export responsive tables with ease.</p>
        </div>
        <div class="p-8 md:p-14">
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-10">
                <div class="flex flex-col gap-2">
                    <label for="rows" class="font-semibold text-gray-700">Number of Rows</label>
                    <input type="number" id="rows" min="1" max="50" value="3" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-accent focus:border-accent text-base shadow-sm">
                </div>
                <div class="flex flex-col gap-2">
                    <label for="cols" class="font-semibold text-gray-700">Number of Columns</label>
                    <input type="number" id="cols" min="1" max="20" value="3" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-accent focus:border-accent text-base shadow-sm">
                </div>
                <div class="flex flex-col gap-2">
                    <label for="hasHeaders" class="font-semibold text-gray-700">Include Headers</label>
                    <select id="hasHeaders" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-accent focus:border-accent text-base shadow-sm">
                        <option value="true">Yes</option>
                        <option value="false">No</option>
                    </select>
                </div>
                <div class="flex flex-col gap-2">
                    <label for="fixedLayout" class="font-semibold text-gray-700 flex items-center gap-1">
                        Fixed Layout
                        <span class="relative group">
                            <span class="ml-1 bg-accent text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold cursor-pointer">?</span>
                            <span class="absolute left-1/2 -translate-x-1/2 bottom-full mb-2 w-64 bg-gray-900 text-gray-100 text-xs rounded-lg p-3 shadow-lg opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity duration-200 z-20">
                                <strong>Fixed Layout (Yes):</strong> Columns maintain equal widths regardless of content length.<br><br>
                                <strong>Auto Layout (No):</strong> Columns automatically adjust to fit their content.
                            </span>
                        </span>
                    </label>
                    <select id="fixedLayout" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-accent focus:border-accent text-base shadow-sm">
                        <option value="true">Yes</option>
                        <option value="false">No</option>
                    </select>
                </div>
            </div>
            <div class="flex flex-wrap md:flex-nowrap gap-2 md:gap-0 mb-8 justify-center items-stretch w-full">
              <!-- Import group -->
              <div class="flex gap-2 mb-2 md:mb-0">
                <button class="bg-white border border-accent text-accent font-semibold py-2 px-7 rounded-xl shadow transition hover:bg-accent hover:text-white focus:ring-2 focus:ring-accent/40 focus:outline-none leading-tight" onclick="openImportModal()">Import Table</button>
              </div>
              <div class="hidden md:block w-px bg-gray-200 mx-2"></div>
              <!-- Generate group -->
              <div class="flex gap-2 mb-2 md:mb-0">
                <button class="bg-accent hover:bg-blue-700 text-white font-semibold py-2 px-7 rounded-xl shadow transition focus:ring-2 focus:ring-accent/40 focus:outline-none leading-tight" onclick="generateTable()">Generate Table</button>
              </div>
              <div class="hidden md:block w-px bg-gray-200 mx-2"></div>
            </div>
            <!-- Add/Remove Row/Column Controls -->
            <div class="flex flex-wrap md:flex-nowrap gap-2 md:gap-0 mb-4 justify-center items-stretch w-full">
              <!-- Add group -->
              <div class="flex gap-2 mb-2 md:mb-0">
                <button class="bg-gray-700 hover:bg-gray-900 text-white font-semibold py-2 px-7 rounded-xl shadow transition focus:ring-2 focus:ring-gray-400/40 focus:outline-none leading-tight" onclick="addRow()">Add Row</button>
                <button class="bg-gray-700 hover:bg-gray-900 text-white font-semibold py-2 px-7 rounded-xl shadow transition focus:ring-2 focus:ring-gray-400/40 focus:outline-none leading-tight" onclick="addColumn()">Add Column</button>
              </div>
              <div class="hidden md:block w-px bg-gray-200 mx-2"></div>
              <!-- Remove group -->
              <div class="flex gap-2">
                <button class="bg-danger hover:bg-red-700 text-white font-semibold py-2 px-7 rounded-xl shadow transition focus:ring-2 focus:ring-red-400/40 focus:outline-none leading-tight" onclick="removeRow()">Remove Row</button>
                <button class="bg-danger hover:bg-red-700 text-white font-semibold py-2 px-7 rounded-xl shadow transition focus:ring-2 focus:ring-red-400/40 focus:outline-none leading-tight" onclick="removeColumn()">Remove Column</button>
              </div>
            </div>
            <div class="overflow-x-auto rounded-xl border border-gray-200 bg-white p-4 mb-14 shadow-sm">
                <table class="w-full min-w-[700px] border-collapse editable-table" id="editableTable">
                    <!-- Table will be generated here -->
                </table>
            </div>
            <div class="mt-14">
                <h2 class="text-gray-900 mb-4 text-2xl font-extrabold tracking-tight">Generated HTML Code</h2>
                <div class="text-xs text-gray-500 italic mb-2">Tip: Use <span class="font-bold">**text**</span> to make text bold in your table cells</div>
                <div class="bg-gray-900 text-gray-100 p-6 rounded-xl font-mono text-sm leading-relaxed overflow-x-auto whitespace-pre-wrap border border-gray-800 shadow" id="htmlOutput" style="font-family: 'Consolas', 'Monaco', monospace;"></div>
                <button class="bg-accent hover:bg-blue-700 text-white mt-4 px-7 py-3 rounded-xl font-semibold shadow transition focus:ring-2 focus:ring-accent/40 focus:outline-none" onclick="copyToClipboard()">Copy HTML Code</button>
            </div>
        </div>
      </div>
    </div>

    <!-- Import Table Modal -->
    <div id="importModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/40 hidden">
      <div class="bg-white rounded-2xl shadow-xl p-8 w-full max-w-lg relative">
        <button class="absolute top-4 right-4 text-gray-400 hover:text-gray-700 text-2xl font-bold" onclick="closeImportModal()">&times;</button>
        <h2 class="text-xl font-bold mb-4">Import Table HTML</h2>
        <textarea id="importTextarea" class="w-full h-40 p-3 border border-gray-300 rounded font-mono text-sm mb-4" placeholder="Paste your &lt;table&gt; HTML here..."></textarea>
        <div class="flex gap-4 justify-end">
          <button class="px-5 py-2 rounded bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold" onclick="closeImportModal()">Cancel</button>
          <button class="px-5 py-2 rounded bg-accent hover:bg-blue-700 text-white font-semibold" onclick="importTableHTML()">Import</button>
        </div>
      </div>
    </div>

    <script>
        let tableData = [];
        let currentRows = 3;
        let currentCols = 3;
        let hasHeaders = true;
        let fixedLayout = true;

        function initializeTable() {
            tableData = [];
            for (let i = 0; i < currentRows; i++) {
                tableData[i] = [];
                for (let j = 0; j < currentCols; j++) {
                    if (i === 0 && hasHeaders) {
                        tableData[i][j] = `Header ${j + 1}`;
                    } else {
                        // For tbody cells, use a consistent 1-based numbering
                        const bodyRowIndex = hasHeaders ? i : i + 1;
                        tableData[i][j] = `Cell ${bodyRowIndex}-${j + 1}`;
                    }
                }
            }
        }

        function generateTable() {
            currentRows = parseInt(document.getElementById('rows').value);
            currentCols = parseInt(document.getElementById('cols').value);
            hasHeaders = document.getElementById('hasHeaders').value === 'true';
            fixedLayout = document.getElementById('fixedLayout').value === 'true';
            
            initializeTable();
            renderTable();
            generateHTML();
        }

        function renderTable() {
            const table = document.getElementById('editableTable');
            table.innerHTML = '';

            // Create thead if headers are enabled
            if (hasHeaders) {
                const thead = table.createTHead();
                const headerRow = thead.insertRow();
                
                for (let j = 0; j < currentCols; j++) {
                    const cell = document.createElement('th');
                    cell.className = 'bg-white text-gray-900 font-bold border border-gray-300 p-3 text-base text-left';
                    const cellContainer = document.createElement('div');
                    cellContainer.className = 'relative';
                    
                    const input = document.createElement('textarea');
                    input.className = 'w-full border-none bg-transparent p-1 text-base min-w-[120px] min-h-[20px] font-inherit focus:ring-2 focus:ring-accent rounded transition resize-none';
                    input.value = tableData[0][j];
                    input.addEventListener('input', function() {
                        tableData[0][j] = this.value;
                        generateHTML();
                    });
                    
                    // Add formatting controls
                    const formatControls = document.createElement('div');
                    formatControls.className = 'absolute top-[-44px] left-0 bg-white border border-accent rounded p-2 hidden z-10 shadow-lg flex gap-2';
                    
                    const boldBtn = document.createElement('button');
                    boldBtn.className = 'bg-gray-100 border border-gray-200 px-2 py-1 rounded text-xs font-bold hover:bg-accent hover:text-white transition';
                    boldBtn.textContent = 'B';
                    boldBtn.title = 'Bold selected text';
                    boldBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        formatSelectedText(input, 'bold');
                        return false;
                    });
                    
                    formatControls.appendChild(boldBtn);
                    
                    input.addEventListener('focus', function() {
                        formatControls.classList.remove('hidden');
                        formatControls.classList.add('active');
                        this.style.display = 'block';
                        const displayDiv = this.parentNode.querySelector('.cell-display');
                        if (displayDiv) displayDiv.style.display = 'none';
                    });
                    input.addEventListener('blur', function() {
                        setTimeout(() => {
                            formatControls.classList.add('hidden');
                            formatControls.classList.remove('active');
                            updateCellDisplay(this);
                        }, 300);
                    });
                    // Create display div for rendered content
                    const displayDiv = document.createElement('div');
                    displayDiv.className = 'cell-display w-full p-1 min-h-[20px] cursor-text min-w-[120px]';
                    displayDiv.addEventListener('click', function() {
                        input.style.display = 'block';
                        this.style.display = 'none';
                        input.focus();
                    });
                    cellContainer.appendChild(formatControls);
                    cellContainer.appendChild(input);
                    cellContainer.appendChild(displayDiv);
                    cell.appendChild(cellContainer);
                    headerRow.appendChild(cell);
                    updateCellDisplay(input);
                }
            }
            // Create tbody
            const tbody = table.createTBody();
            const startRow = hasHeaders ? 1 : 0;
            for (let i = startRow; i < currentRows; i++) {
                const row = tbody.insertRow();
                for (let j = 0; j < currentCols; j++) {
                    const cell = document.createElement('td');
                    cell.className = 'bg-white border border-gray-200 p-3 text-base text-left';
                    const cellContainer = document.createElement('div');
                    cellContainer.className = 'relative';
                    const input = document.createElement('textarea');
                    input.className = 'w-full border-none bg-transparent p-1 text-base min-w-[120px] min-h-[20px] font-inherit focus:ring-2 focus:ring-accent rounded transition resize-none';
                    input.value = tableData[i][j];
                    input.addEventListener('input', function() {
                        tableData[i][j] = this.value;
                        generateHTML();
                    });
                    // Add formatting controls
                    const formatControls = document.createElement('div');
                    formatControls.className = 'absolute top-[-44px] left-0 bg-white border border-accent rounded p-2 hidden z-10 shadow-lg flex gap-2';
                    const boldBtn = document.createElement('button');
                    boldBtn.className = 'bg-gray-100 border border-gray-200 px-2 py-1 rounded text-xs font-bold hover:bg-accent hover:text-white transition';
                    boldBtn.textContent = 'B';
                    boldBtn.title = 'Bold selected text';
                    boldBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        formatSelectedText(input, 'bold');
                        return false;
                    });
                    formatControls.appendChild(boldBtn);
                    input.addEventListener('focus', function() {
                        formatControls.classList.remove('hidden');
                        formatControls.classList.add('active');
                        this.style.display = 'block';
                        const displayDiv = this.parentNode.querySelector('.cell-display');
                        if (displayDiv) displayDiv.style.display = 'none';
                    });
                    input.addEventListener('blur', function() {
                        setTimeout(() => {
                            formatControls.classList.add('hidden');
                            formatControls.classList.remove('active');
                            updateCellDisplay(this);
                        }, 300);
                    });
                    const displayDiv = document.createElement('div');
                    displayDiv.className = 'cell-display w-full p-1 min-h-[20px] cursor-text min-w-[120px]';
                    displayDiv.addEventListener('click', function() {
                        input.style.display = 'block';
                        this.style.display = 'none';
                        input.focus();
                    });
                    cellContainer.appendChild(formatControls);
                    cellContainer.appendChild(input);
                    cellContainer.appendChild(displayDiv);
                    cell.appendChild(cellContainer);
                    row.appendChild(cell);
                    updateCellDisplay(input);
                }
            }
        }

        function updateCellDisplay(textarea) {
            const displayDiv = textarea.parentNode.querySelector('.cell-display');
            if (displayDiv) {
                const content = textarea.value || '';
                const processedContent = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                displayDiv.innerHTML = processedContent || '&nbsp;';
                
                // Hide textarea, show display only when not focused
                if (document.activeElement !== textarea) {
                    textarea.style.display = 'none';
                    displayDiv.style.display = 'block';
                }
            }
        }

        function formatSelectedText(textarea, format) {
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const selectedText = textarea.value.substring(start, end);
            
            if (selectedText) {
                let formattedText = selectedText;
                
                if (format === 'bold') {
                    // Check if already bold
                    if (selectedText.startsWith('**') && selectedText.endsWith('**')) {
                        formattedText = selectedText.slice(2, -2);
                    } else {
                        formattedText = `**${selectedText}**`;
                    }
                }
                
                const newValue = textarea.value.substring(0, start) + formattedText + textarea.value.substring(end);
                textarea.value = newValue;
                
                // Update table data - need to find the correct row/cell indices
                const cell = textarea.closest('td, th');
                const row = textarea.closest('tr');
                const table = textarea.closest('table');
                
                let rowIndex, cellIndex;
                
                // Check if we're in thead or tbody
                if (cell.tagName === 'TH') {
                    // We're in a header row
                    rowIndex = 0;
                    cellIndex = Array.from(row.children).indexOf(cell);
                } else {
                    // We're in tbody
                    const tbody = textarea.closest('tbody');
                    const tbodyRows = Array.from(tbody.children);
                    const tbodyRowIndex = tbodyRows.indexOf(row);
                    
                    // Add 1 to account for header row if it exists
                    rowIndex = hasHeaders ? tbodyRowIndex + 1 : tbodyRowIndex;
                    cellIndex = Array.from(row.children).indexOf(cell);
                }
                
                tableData[rowIndex][cellIndex] = newValue;
                
                // Regenerate HTML
                generateHTML();
                
                // Keep focus on the textarea
                setTimeout(() => {
                    textarea.focus();
                    textarea.setSelectionRange(start, start + formattedText.length);
                }, 10);
            }
        }

        function addRow() {
            currentRows++;
            const newRowData = [];
            for (let j = 0; j < currentCols; j++) {
                const bodyRowIndex = hasHeaders ? currentRows - 1 : currentRows;
                newRowData.push(`Cell ${bodyRowIndex}-${j + 1}`);
            }
            tableData.push(newRowData);
            document.getElementById('rows').value = currentRows;
            renderTable();
            generateHTML();
        }

        function addColumn() {
            currentCols++;
            for (let i = 0; i < currentRows; i++) {
                if (i === 0 && hasHeaders) {
                    tableData[i].push(`Header ${currentCols}`);
                } else {
                    const bodyRowIndex = hasHeaders ? i : i + 1;
                    tableData[i].push(`Cell ${bodyRowIndex}-${currentCols}`);
                }
            }
            document.getElementById('cols').value = currentCols;
            renderTable();
            generateHTML();
        }

        function removeRow() {
            if (currentRows > 1) {
                currentRows--;
                tableData.pop();
                document.getElementById('rows').value = currentRows;
                renderTable();
                generateHTML();
            }
        }

        function removeColumn() {
            if (currentCols > 1) {
                currentCols--;
                for (let i = 0; i < currentRows; i++) {
                    tableData[i].pop();
                }
                document.getElementById('cols').value = currentCols;
                renderTable();
                generateHTML();
            }
        }

        function generateHTML() {
            let html = '<figure class="ad-table">\n';
            
            if (fixedLayout) {
                html += '  <table class="has-fixed-layout">\n';
            } else {
                html += '  <table>\n';
            }
            
            // Add thead if headers are enabled
            if (hasHeaders) {
                html += '    <thead>\n';
                html += '      <tr>\n';
                for (let j = 0; j < currentCols; j++) {
                    const content = tableData[0][j] || '';
                    const processedContent = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    html += `        <th>${processedContent}</th>\n`;
                }
                html += '      </tr>\n';
                html += '    </thead>\n';
            }
            
            // Add tbody
            html += '    <tbody>\n';
            const startRow = hasHeaders ? 1 : 0;
            for (let i = startRow; i < currentRows; i++) {
                html += '      <tr>\n';
                for (let j = 0; j < currentCols; j++) {
                    const content = tableData[i][j] || '';
                    const processedContent = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    html += `        <td>${processedContent}</td>\n`;
                }
                html += '      </tr>\n';
            }
            html += '    </tbody>\n';
            
            html += '  </table>\n';
            html += '</figure>';
            
            document.getElementById('htmlOutput').textContent = html;
        }

        function copyToClipboard() {
            const htmlOutput = document.getElementById('htmlOutput');
            const textArea = document.createElement('textarea');
            textArea.value = htmlOutput.textContent;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            btn.style.background = '#28a745';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '#28a745';
            }, 2000);
        }

        function openImportModal() {
          document.getElementById('importModal').classList.remove('hidden');
          document.getElementById('importTextarea').value = '';
        }
        function closeImportModal() {
          document.getElementById('importModal').classList.add('hidden');
        }
        function importTableHTML() {
          const html = document.getElementById('importTextarea').value;
          if (!html.trim()) return;
          const parser = new DOMParser();
          let doc;
          try {
            doc = parser.parseFromString(html, 'text/html');
          } catch (e) {
            alert('Could not parse HTML.');
            return;
          }
          const table = doc.querySelector('table');
          if (!table) {
            alert('No <table> found in the provided HTML.');
            return;
          }
          // Parse headers
          let headers = [];
          let detectedHeaders = false;
          const thead = table.querySelector('thead');
          if (thead) {
            const headerRow = thead.querySelector('tr');
            if (headerRow) {
              headers = Array.from(headerRow.children).map(cell => cell.textContent.trim());
              detectedHeaders = true;
            }
          } else {
            // Try first row as header if all th
            const firstRow = table.querySelector('tr');
            if (firstRow && Array.from(firstRow.children).every(cell => cell.tagName === 'TH')) {
              headers = Array.from(firstRow.children).map(cell => cell.textContent.trim());
              detectedHeaders = true;
            }
          }
          // Parse rows
          let rows = [];
          let rowEls = Array.from(table.querySelectorAll('tbody tr'));
          if (rowEls.length === 0) {
            // fallback: all tr except thead
            rowEls = Array.from(table.querySelectorAll('tr'));
            if (detectedHeaders) rowEls = rowEls.slice(1);
          }
          for (const row of rowEls) {
            rows.push(Array.from(row.children).map(cell => cell.textContent.trim()));
          }
          // Set up tableData
          tableData = [];
          if (detectedHeaders) {
            tableData.push(headers);
            for (const row of rows) {
              // pad or trim to match header length
              const rowData = row.slice(0, headers.length);
              while (rowData.length < headers.length) rowData.push('');
              tableData.push(rowData);
            }
            currentRows = tableData.length;
            currentCols = headers.length;
            hasHeaders = true;
          } else {
            // No headers
            for (const row of rows) {
              tableData.push(row);
            }
            currentRows = tableData.length;
            currentCols = tableData[0] ? tableData[0].length : 0;
            hasHeaders = false;
          }
          document.getElementById('rows').value = currentRows;
          document.getElementById('cols').value = currentCols;
          document.getElementById('hasHeaders').value = hasHeaders ? 'true' : 'false';
          closeImportModal();
          renderTable();
          generateHTML();
        }

        // Initialize the table on page load
        window.addEventListener('load', function() {
            generateTable();
        });
    </script>
</body>
</html>